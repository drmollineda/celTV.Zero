diff -Naurp a/xbmc/storage/MediaManager.cpp b/xbmc/storage/MediaManager.cpp
--- a/xbmc/storage/MediaManager.cpp	2020-11-23 09:29:15.474421193 -0500
+++ b/xbmc/storage/MediaManager.cpp	2020-11-23 10:56:24.502410148 -0500
@@ -38,6 +38,10 @@
 #endif
 #endif
 #include "Autorun.h"
+#include "addons/PVRClient.h"
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "pvr/timers/PVRTimers.h"
 #include "GUIUserMessages.h"
 #include "settings/MediaSourceSettings.h"
 #include "settings/Settings.h"
@@ -70,13 +74,16 @@
 #include <string>
 #include <vector>
 
+#include <sys/stat.h>
+#include "ServiceBroker.h"
 using namespace XFILE;
+using namespace PVR;
 
 #ifdef HAS_DVD_DRIVE
 using namespace MEDIA_DETECT;
 #endif
 
-const char MEDIA_SOURCES_XML[] = { "special://profile/mediasources.xml" };
+const char MEDIA_SOURCES_XML[] = {"special://profile/mediasources.xml"};
 
 class CMediaManager g_mediaManager;
 
@@ -99,15 +106,15 @@ void CMediaManager::Initialize()
 {
   if (!m_platformStorage)
   {
-    #if defined(TARGET_DARWIN)
-      m_platformStorage = new CDarwinStorageProvider();
-    #elif defined(TARGET_ANDROID)
-      m_platformStorage = new CAndroidStorageProvider();
-    #elif defined(TARGET_POSIX)
-      m_platformStorage = new CLinuxStorageProvider();
-    #elif TARGET_WINDOWS
-      m_platformStorage = new CWin32StorageProvider();
-    #endif
+#if defined(TARGET_DARWIN)
+    m_platformStorage = new CDarwinStorageProvider();
+#elif defined(TARGET_ANDROID)
+    m_platformStorage = new CAndroidStorageProvider();
+#elif defined(TARGET_POSIX)
+    m_platformStorage = new CLinuxStorageProvider();
+#elif TARGET_WINDOWS
+    m_platformStorage = new CWin32StorageProvider();
+#endif
   }
 #ifdef HAS_DVD_DRIVE
   m_strFirstAvailDrive = m_platformStorage->GetFirstOpticalDeviceFileName();
@@ -122,11 +129,11 @@ bool CMediaManager::LoadSources()
 
   // load xml file...
   CXBMCTinyXML xmlDoc;
-  if ( !xmlDoc.LoadFile( MEDIA_SOURCES_XML ) )
+  if (!xmlDoc.LoadFile(MEDIA_SOURCES_XML))
     return false;
 
-  TiXmlElement* pRootElement = xmlDoc.RootElement();
-  if ( !pRootElement || strcmpi(pRootElement->Value(), "mediasources") != 0)
+  TiXmlElement *pRootElement = xmlDoc.RootElement();
+  if (!pRootElement || strcmpi(pRootElement->Value(), "mediasources") != 0)
   {
     CLog::Log(LOGERROR, "Error loading %s, Line %d (%s)", MEDIA_SOURCES_XML, xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
     return false;
@@ -157,7 +164,8 @@ bool CMediaManager::SaveSources()
   CXBMCTinyXML xmlDoc;
   TiXmlElement xmlRootElement("mediasources");
   TiXmlNode *pRoot = xmlDoc.InsertEndChild(xmlRootElement);
-  if (!pRoot) return false;
+  if (!pRoot)
+    return false;
 
   TiXmlElement networkNode("network");
   TiXmlNode *pNetworkNode = pRoot->InsertEndChild(networkNode);
@@ -213,7 +221,7 @@ void CMediaManager::GetNetworkLocations(
     share.strPath = "nfs://";
     share.strName = g_localizeStrings.Get(20259);
     locations.push_back(share);
-#endif// HAS_FILESYSTEM_NFS
+#endif // HAS_FILESYSTEM_NFS
 
 #ifdef HAS_UPNP
     std::string strDevices = g_localizeStrings.Get(33040); //"% Devices"
@@ -221,7 +229,7 @@ void CMediaManager::GetNetworkLocations(
     share.strName = StringUtils::Format(strDevices.c_str(), "UPnP"); //"UPnP Devices"
     locations.push_back(share);
 #endif
-    
+
 #ifdef HAS_ZEROCONF
     share.strPath = "zeroconf://";
     share.strName = g_localizeStrings.Get(20262);
@@ -239,9 +247,9 @@ bool CMediaManager::AddNetworkLocation(c
   return SaveSources();
 }
 
-bool CMediaManager::HasLocation(const std::string& path) const
+bool CMediaManager::HasLocation(const std::string &path) const
 {
-  for (unsigned int i=0;i<m_locations.size();++i)
+  for (unsigned int i = 0; i < m_locations.size(); ++i)
   {
     if (URIUtils::CompareWithoutSlashAtEnd(m_locations[i].path, path))
       return true;
@@ -250,15 +258,14 @@ bool CMediaManager::HasLocation(const st
   return false;
 }
 
-
-bool CMediaManager::RemoveLocation(const std::string& path)
+bool CMediaManager::RemoveLocation(const std::string &path)
 {
-  for (unsigned int i=0;i<m_locations.size();++i)
+  for (unsigned int i = 0; i < m_locations.size(); ++i)
   {
     if (URIUtils::CompareWithoutSlashAtEnd(m_locations[i].path, path))
     {
       // prompt for sources, remove, cancel,
-      m_locations.erase(m_locations.begin()+i);
+      m_locations.erase(m_locations.begin() + i);
       return SaveSources();
     }
   }
@@ -266,9 +273,9 @@ bool CMediaManager::RemoveLocation(const
   return false;
 }
 
-bool CMediaManager::SetLocationPath(const std::string& oldPath, const std::string& newPath)
+bool CMediaManager::SetLocationPath(const std::string &oldPath, const std::string &newPath)
 {
-  for (unsigned int i=0;i<m_locations.size();++i)
+  for (unsigned int i = 0; i < m_locations.size(); ++i)
   {
     if (URIUtils::CompareWithoutSlashAtEnd(m_locations[i].path, oldPath))
     {
@@ -288,10 +295,10 @@ void CMediaManager::AddAutoSource(const
   CMediaSourceSettings::GetInstance().AddShare("music", share);
   CMediaSourceSettings::GetInstance().AddShare("programs", share);
   CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_SOURCES);
-  g_windowManager.SendThreadMessage( msg );
+  g_windowManager.SendThreadMessage(msg);
 
 #ifdef HAS_DVD_DRIVE
-  if(bAutorun)
+  if (bAutorun)
     MEDIA_DETECT::CAutorun::ExecuteAutorun(share.strPath);
 #endif
 }
@@ -304,7 +311,7 @@ void CMediaManager::RemoveAutoSource(con
   CMediaSourceSettings::GetInstance().DeleteSource("music", share.strName, share.strPath, true);
   CMediaSourceSettings::GetInstance().DeleteSource("programs", share.strName, share.strPath, true);
   CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_SOURCES);
-  g_windowManager.SendThreadMessage( msg );
+  g_windowManager.SendThreadMessage(msg);
 
 #ifdef HAS_DVD_DRIVE
   // delete cached CdInfo if any
@@ -316,23 +323,23 @@ void CMediaManager::RemoveAutoSource(con
 // AutoSource status functions:
 //! @todo translate cdda://<device>/
 
-std::string CMediaManager::TranslateDevicePath(const std::string& devicePath, bool bReturnAsDevice)
+std::string CMediaManager::TranslateDevicePath(const std::string &devicePath, bool bReturnAsDevice)
 {
   CSingleLock waitLock(m_muAutoSource);
   std::string strDevice = devicePath;
   // fallback for cdda://local/ and empty devicePath
 #ifdef HAS_DVD_DRIVE
-  if(devicePath.empty() || StringUtils::StartsWith(devicePath, "cdda://local"))
+  if (devicePath.empty() || StringUtils::StartsWith(devicePath, "cdda://local"))
     strDevice = m_strFirstAvailDrive;
 #endif
 
 #ifdef TARGET_WINDOWS
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return "";
 
-  if(bReturnAsDevice == false)
-    StringUtils::Replace(strDevice, "\\\\.\\","");
-  else if(!strDevice.empty() && strDevice[1]==':')
+  if (bReturnAsDevice == false)
+    StringUtils::Replace(strDevice, "\\\\.\\", "");
+  else if (!strDevice.empty() && strDevice[1] == ':')
     strDevice = StringUtils::Format("\\\\.\\%c:", strDevice[0]);
 
   URIUtils::RemoveSlashAtEnd(strDevice);
@@ -340,24 +347,24 @@ std::string CMediaManager::TranslateDevi
   return strDevice;
 }
 
-bool CMediaManager::IsDiscInDrive(const std::string& devicePath)
+bool CMediaManager::IsDiscInDrive(const std::string &devicePath)
 {
 #ifdef HAS_DVD_DRIVE
 #ifdef TARGET_WINDOWS
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return false;
 
   std::string strDevice = TranslateDevicePath(devicePath, false);
-  std::map<std::string,CCdInfo*>::iterator it;
+  std::map<std::string, CCdInfo *>::iterator it;
   CSingleLock waitLock(m_muAutoSource);
   it = m_mapCdInfo.find(strDevice);
-  if(it != m_mapCdInfo.end())
+  if (it != m_mapCdInfo.end())
     return true;
   else
     return false;
 #else
-  if(URIUtils::IsDVD(devicePath) || devicePath.empty())
-    return MEDIA_DETECT::CDetectDVDMedia::IsDiscInDrive();   //! @todo switch all ports to use auto sources
+  if (URIUtils::IsDVD(devicePath) || devicePath.empty())
+    return MEDIA_DETECT::CDetectDVDMedia::IsDiscInDrive(); //! @todo switch all ports to use auto sources
   else
     return true; // Assume other paths to be mounted already
 #endif
@@ -366,21 +373,21 @@ bool CMediaManager::IsDiscInDrive(const
 #endif
 }
 
-bool CMediaManager::IsAudio(const std::string& devicePath)
+bool CMediaManager::IsAudio(const std::string &devicePath)
 {
 #ifdef HAS_DVD_DRIVE
 #ifdef TARGET_WINDOWS
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return false;
 
-  CCdInfo* pCdInfo = GetCdInfo(devicePath);
-  if(pCdInfo != NULL && pCdInfo->IsAudio(1))
+  CCdInfo *pCdInfo = GetCdInfo(devicePath);
+  if (pCdInfo != NULL && pCdInfo->IsAudio(1))
     return true;
 
   return false;
 #else
   //! @todo switch all ports to use auto sources
-  MEDIA_DETECT::CCdInfo* pInfo = MEDIA_DETECT::CDetectDVDMedia::GetCdInfo();
+  MEDIA_DETECT::CCdInfo *pInfo = MEDIA_DETECT::CDetectDVDMedia::GetCdInfo();
   if (pInfo != NULL && pInfo->IsAudio(1))
     return true;
 #endif
@@ -397,18 +404,18 @@ bool CMediaManager::HasOpticalDrive()
   return false;
 }
 
-DWORD CMediaManager::GetDriveStatus(const std::string& devicePath)
+DWORD CMediaManager::GetDriveStatus(const std::string &devicePath)
 {
 #ifdef HAS_DVD_DRIVE
 #ifdef TARGET_WINDOWS
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return DRIVE_NOT_READY;
 
   std::string strDevice = TranslateDevicePath(devicePath, true);
   DWORD dwRet = DRIVE_NOT_READY;
   int status = CWIN32Util::GetDriveStatus(strDevice);
 
-  switch(status)
+  switch (status)
   {
   case -1: // error
     dwRet = DRIVE_NOT_READY;
@@ -433,28 +440,28 @@ DWORD CMediaManager::GetDriveStatus(cons
 }
 
 #ifdef HAS_DVD_DRIVE
-CCdInfo* CMediaManager::GetCdInfo(const std::string& devicePath)
+CCdInfo *CMediaManager::GetCdInfo(const std::string &devicePath)
 {
 #ifdef TARGET_WINDOWS
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return NULL;
-  
+
   std::string strDevice = TranslateDevicePath(devicePath, false);
-  std::map<std::string,CCdInfo*>::iterator it;
+  std::map<std::string, CCdInfo *>::iterator it;
   {
     CSingleLock waitLock(m_muAutoSource);
     it = m_mapCdInfo.find(strDevice);
-    if(it != m_mapCdInfo.end())
+    if (it != m_mapCdInfo.end())
       return it->second;
   }
 
-  CCdInfo* pCdInfo=NULL;
+  CCdInfo *pCdInfo = NULL;
   CCdIoSupport cdio;
-  pCdInfo = cdio.GetCdInfo((char*)strDevice.c_str());
-  if(pCdInfo!=NULL)
+  pCdInfo = cdio.GetCdInfo((char *)strDevice.c_str());
+  if (pCdInfo != NULL)
   {
     CSingleLock waitLock(m_muAutoSource);
-    m_mapCdInfo.insert(std::pair<std::string,CCdInfo*>(strDevice,pCdInfo));
+    m_mapCdInfo.insert(std::pair<std::string, CCdInfo *>(strDevice, pCdInfo));
   }
 
   return pCdInfo;
@@ -463,19 +470,19 @@ CCdInfo* CMediaManager::GetCdInfo(const
 #endif
 }
 
-bool CMediaManager::RemoveCdInfo(const std::string& devicePath)
+bool CMediaManager::RemoveCdInfo(const std::string &devicePath)
 {
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return false;
 
   std::string strDevice = TranslateDevicePath(devicePath, false);
 
-  std::map<std::string,CCdInfo*>::iterator it;
+  std::map<std::string, CCdInfo *>::iterator it;
   CSingleLock waitLock(m_muAutoSource);
   it = m_mapCdInfo.find(strDevice);
-  if(it != m_mapCdInfo.end())
+  if (it != m_mapCdInfo.end())
   {
-    if(it->second != NULL)
+    if (it->second != NULL)
       delete it->second;
 
     m_mapCdInfo.erase(it);
@@ -484,10 +491,10 @@ bool CMediaManager::RemoveCdInfo(const s
   return false;
 }
 
-std::string CMediaManager::GetDiskLabel(const std::string& devicePath)
+std::string CMediaManager::GetDiskLabel(const std::string &devicePath)
 {
 #ifdef TARGET_WINDOWS
-  if(!m_bhasoptical)
+  if (!m_bhasoptical)
     return "";
 
   std::string strDevice = TranslateDevicePath(devicePath);
@@ -496,7 +503,7 @@ std::string CMediaManager::GetDiskLabel(
   URIUtils::AddSlashAtEnd(strDevice);
   std::wstring strDeviceW;
   g_charsetConverter.utf8ToW(strDevice, strDeviceW);
-  if(GetVolumeInformationW(strDeviceW.c_str(), cVolumenName, 127, NULL, NULL, NULL, cFSName, 127)==0)
+  if (GetVolumeInformationW(strDeviceW.c_str(), cVolumenName, 127, NULL, NULL, NULL, cFSName, 127) == 0)
     return "";
   g_charsetConverter.wToUTF8(cVolumenName, strDevice);
   return StringUtils::TrimRight(strDevice, " ");
@@ -505,11 +512,11 @@ std::string CMediaManager::GetDiskLabel(
 #endif
 }
 
-std::string CMediaManager::GetDiskUniqueId(const std::string& devicePath)
+std::string CMediaManager::GetDiskUniqueId(const std::string &devicePath)
 {
   std::string mediaPath;
 
-  CCdInfo* pInfo = g_mediaManager.GetCdInfo(devicePath);
+  CCdInfo *pInfo = g_mediaManager.GetCdInfo(devicePath);
   if (pInfo == NULL)
     return "";
 
@@ -530,19 +537,18 @@ std::string CMediaManager::GetDiskUnique
   }
 #endif
 
-  // Try finding VIDEO_TS/VIDEO_TS.IFO - this indicates a DVD disc is inserted 
-  std::string pathVideoTS = URIUtils::AddFileToFolder(mediaPath, "VIDEO_TS"); 
-  if(!CFile::Exists(URIUtils::AddFileToFolder(pathVideoTS, "VIDEO_TS.IFO"))) 
+  // Try finding VIDEO_TS/VIDEO_TS.IFO - this indicates a DVD disc is inserted
+  std::string pathVideoTS = URIUtils::AddFileToFolder(mediaPath, "VIDEO_TS");
+  if (!CFile::Exists(URIUtils::AddFileToFolder(pathVideoTS, "VIDEO_TS.IFO")))
     return ""; // return empty
 
-  // correct the filename if needed 
+  // correct the filename if needed
   if (StringUtils::StartsWith(pathVideoTS, "dvd://") ||
       StringUtils::StartsWith(pathVideoTS, "iso9660://"))
-    pathVideoTS = g_mediaManager.TranslateDevicePath(""); 
+    pathVideoTS = g_mediaManager.TranslateDevicePath("");
 
   CLog::Log(LOGDEBUG, "GetDiskUniqueId: Trying to retrieve ID for path %s", pathVideoTS.c_str());
 
-
   CFileItem item(pathVideoTS, false);
   CDVDInputStreamNavigator dvdNavigator(NULL, item);
   dvdNavigator.Open();
@@ -564,9 +570,9 @@ std::string CMediaManager::GetDiscPath()
   CSingleLock lock(m_CritSecStorageProvider);
   VECSOURCES drives;
   m_platformStorage->GetRemovableDrives(drives);
-  for(unsigned i = 0; i < drives.size(); ++i)
+  for (unsigned i = 0; i < drives.size(); ++i)
   {
-    if(drives[i].m_iDriveType == CMediaSource::SOURCE_TYPE_DVD)
+    if (drives[i].m_iDriveType == CMediaSource::SOURCE_TYPE_DVD)
       return drives[i].strPath;
   }
 
@@ -582,25 +588,25 @@ void CMediaManager::SetHasOpticalDrive(b
   m_bhasoptical = bstatus;
 }
 
-bool CMediaManager::Eject(const std::string& mountpath)
+bool CMediaManager::Eject(const std::string &mountpath)
 {
   CSingleLock lock(m_CritSecStorageProvider);
   return m_platformStorage->Eject(mountpath);
 }
 
-void CMediaManager::EjectTray( const bool bEject, const char cDriveLetter )
+void CMediaManager::EjectTray(const bool bEject, const char cDriveLetter)
 {
 #ifdef HAS_DVD_DRIVE
 #ifdef TARGET_WINDOWS
   CWIN32Util::EjectTray(cDriveLetter);
 #else
   std::shared_ptr<CLibcdio> c_cdio = CLibcdio::GetInstance();
-  char* dvdDevice = c_cdio->GetDeviceFileName();
+  char *dvdDevice = c_cdio->GetDeviceFileName();
   m_isoReader.Reset();
-  int nRetries=3;
+  int nRetries = 3;
   while (nRetries-- > 0)
   {
-    CdIo_t* cdio = c_cdio->cdio_open(dvdDevice, DRIVER_UNKNOWN);
+    CdIo_t *cdio = c_cdio->cdio_open(dvdDevice, DRIVER_UNKNOWN);
     if (cdio)
     {
       c_cdio->cdio_eject_media(&cdio);
@@ -621,7 +627,7 @@ void CMediaManager::CloseTray(const char
 #elif defined(TARGET_FREEBSD)
   // NYI
 #elif defined(TARGET_POSIX)
-  char* dvdDevice = CLibcdio::GetInstance()->GetDeviceFileName();
+  char *dvdDevice = CLibcdio::GetInstance()->GetDeviceFileName();
   if (strlen(dvdDevice) != 0)
   {
     int fd = open(dvdDevice, O_RDONLY | O_NONBLOCK);
@@ -664,8 +670,8 @@ void CMediaManager::ProcessEvents()
     // else TranslateDevicePath wouldn't give the correct device
     m_strFirstAvailDrive = m_platformStorage->GetFirstOpticalDeviceFileName();
 #endif
-    
-    CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
+
+    CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_SOURCES);
     g_windowManager.SendThreadMessage(msg);
   }
 }
@@ -676,6 +682,44 @@ std::vector<std::string> CMediaManager::
   return m_platformStorage->GetDiskUsage();
 }
 
+static void HandlePVRRedirection(const char *symlinkPath, const char *pvrFolder)
+{
+  bool regen = false;
+  struct stat buf;
+  char *linkFilename;
+
+  if (stat(pvrFolder, &buf) != 0 && mkdir(pvrFolder, 0777) != 0)
+  {
+    // fail: if pvr folder is missing and could not be created.
+    return;
+  }
+
+  if (lstat(symlinkPath, &buf) != 0)
+  {
+    // regen if the symlink is missing
+    regen = true;
+  }
+  else
+  {
+    linkFilename = (char *)malloc(buf.st_size + 1);
+
+    if (readlink(symlinkPath, linkFilename, buf.st_size + 1) > 0)
+    {
+      linkFilename[buf.st_size] = '\0';
+
+      // regen if symlink is invalid
+      regen = stat(linkFilename, &buf) != 0 && (unlink(symlinkPath) || true);
+    }
+
+    free(linkFilename);
+  }
+
+  if (regen)
+  {
+    symlink(pvrFolder, symlinkPath);
+  }
+}
+
 void CMediaManager::OnStorageAdded(const std::string &label, const std::string &path)
 {
 #ifdef HAS_DVD_DRIVE
@@ -687,11 +731,61 @@ void CMediaManager::OnStorageAdded(const
   else
     CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(13021), label, TOAST_DISPLAY_TIME, false);
 #endif
+
+  const char *symlink = "/storage/recordings";
+  const char *storage = (path + "/recordings").c_str();
+
+  HandlePVRRedirection(symlink, storage);
+}
+
+static bool DeletePVRRedirection(const char *symlinkPath, const char *pvrFolder)
+{
+  struct stat buf;
+  char *linkFilename;
+  bool stopTimers = false;
+
+  if (lstat(symlinkPath, &buf) != 0)
+  {
+    return false;
+  }
+
+  linkFilename = (char *)malloc(buf.st_size + 1);
+
+  if (readlink(symlinkPath, linkFilename, buf.st_size + 1) > 0)
+  {
+    linkFilename[buf.st_size] = '\0';
+
+    if (stat(linkFilename, &buf) != 0)
+    {
+      stopTimers = true;
+      unlink(symlinkPath);
+    }
+  }
+
+  free(linkFilename);
+
+  return stopTimers;
 }
 
 void CMediaManager::OnStorageSafelyRemoved(const std::string &label)
 {
   CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(13023), label, TOAST_DISPLAY_TIME, false);
+
+  const char *symlink = "/storage/recordings";
+  const char *storage = ("/var/media/" + label + "/recordings").c_str();
+
+  if (DeletePVRRedirection(symlink, storage))
+  {
+//    if (CServiceBroker::GetPVRManager().IsRecording())
+//    {
+//      for (const auto &timer : CServiceBroker::GetPVRManager().Timers()->GetActiveTVRecordings())
+//      {
+//        CPVRTimers::DeleteTimer(timer, true, false);
+//      }
+  }
+
+  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, "Sin dispositivo de grabaci√≥n", label, TOAST_DISPLAY_TIME, false);
+
 }
 
 void CMediaManager::OnStorageUnsafelyRemoved(const std::string &label)
